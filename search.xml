<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[FastText之监督学习]]></title>
      <url>/2018/07/01/fast_text_supervised/</url>
      <content type="html"><![CDATA[<p>最近，在学习fasttext相关源码，这篇文章主要分享下学习监督学习相关的学习心得。</p>
<h3>主要架构</h3>
<p><img src="/images/fast.png" alt=""></p>
<ol>
<li>输入：term级别词向量，比如输入“中国” “新” “说唱”三个term，每个词进入系统前都被随机初始化成了dim纬度的向量</li>
<li>hidden : 将所有term的向量进行相加，然后求解平均值，组成短片段的向量表示</li>
<li>输出：label个向量, 即我们要分类的个数</li>
<li>对输出对值求softmax，loss函数使用crossEntroy loss</li>
</ol>
<h3>求解的参数</h3>
<p>和传统lr的区别是：传统lr我们是知道特征的值的，只需要求解w的值；但是，这里我们词向量也是未知的，也是需要求解的, 因此需要求解的参数是以下两个：</p>
<ol>
<li>hidder layer和最终输出的矩阵权重w</li>
<li>每个单词的词向量</li>
</ol>
<h3>理论基础</h3>
<p><img src="/images/closs_entropy.png" alt=""></p>
<ol>
<li>
<p>crossEntropy loss梯度
<img src="/images/closs_define.png" alt=""></p>
</li>
<li>
<p>求解梯度
当i == j时:
<img src="/images/closs_equal.png" alt=""></p>
</li>
<li>
<p>求解梯度
当i != j时:
<img src="/images/not_closs_equal.png" alt=""></p>
</li>
<li>
<p>结合代码分析
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">real Model::softmax(<span class="keyword">int32_t</span> target, real lr) &#123;</div><div class="line">  grad_.zero();</div><div class="line">  computeOutputSoftmax();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; osz_; i++) &#123;</div><div class="line">    <span class="comment">//alpha就是loss对softmax之前变量梯度的计算</span></div><div class="line">    <span class="comment">//如果i == target, 梯度为output[i] - label</span></div><div class="line">    <span class="comment">//如果i != target, 梯度为output[i]</span></div><div class="line">    <span class="comment">//这儿用的label - ouput[i], 因为减去梯度，相当于加上负梯度</span></div><div class="line">    real label = (i == target) ? <span class="number">1.0</span> : <span class="number">0.0</span>;</div><div class="line">    real alpha = lr * (label - output_[i]);</div><div class="line">    grad_.addRow(*wo_, i, alpha);</div><div class="line">    wo_-&gt;addRow(hidden_, i, alpha);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> -<span class="built_in">log</span>(output_[target]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>举例
如果类别一共三维，经过softmax后的向量为[0.1, 0.3, 0.6], 第二维label为1，则loss对原始输入的梯度为[0.1, -0.7, 0.6], 可见需要在第二维上重点调整，以调到最大。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[如何使用yaml]]></title>
      <url>/2018/06/01/how_to_use_yaml/</url>
      <content type="html"><![CDATA[<h3>如何使用yaml</h3>
<h4>背景</h4>
<p>一开始是使用ConfigParser这个python自带的库种，但发现这个parser能力有限，很多多级的操作都不支持，因此，选择了yaml</p>
<h4>使用技巧</h4>
<ol>
<li>
<p>load xml
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> yaml</div><div class="line">f = open(<span class="string">"path"</span>)</div><div class="line">yaml_res = yaml.load(f)</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>key-value格式的，value和冒号之前必须加一个空格(不能使用tab键), 比如, video: 0.7</p>
</li>
<li>
<p>嵌套数组形式
假设路径是这种形式：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">path_all:</div><div class="line"> - path_1_1: <span class="number">1</span></div><div class="line">   path_1_2: <span class="number">2</span></div><div class="line"> - path_2_1: <span class="number">2</span></div><div class="line">   path_2_2: <span class="number">2</span></div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>则通过yaml解析出来的json是:
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'path_all'</span>: [&#123;<span class="string">'path_1_1'</span>: <span class="number">1</span>, <span class="string">'path_1_2'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'path_2_2'</span>: <span class="number">2</span>, <span class="string">'path_2_1'</span>: <span class="number">2</span>&#125;]&#125;</div></pre></td></tr></table></figure></p>
<h4>参考文件</h4>
<ol>
<li>http://www.ruanyifeng.com/blog/2016/07/yaml.html</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 程序技巧 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[威尔逊区间的应用]]></title>
      <url>/2018/05/01/wilson_interval/</url>
      <content type="html"><![CDATA[<h3>背景</h3>
<p>点赞点踩是互联网上收集用户反馈的一个非常重要的手段，这些后验特征对于结果的排序是非常有用的；但是，我们经常会遇到这样的问题，
一个结果有5条1分的评价, 0条0分的评价，一个结果有480个1分的评价，20个0分的评价，如果直接按照good / all来算，第一个结果是1.0，第二个结果
是4.8；可是显然，第二条结果是大概率好于第一条结果的。由此，我们引入威尔逊区间的概念。</p>
<h3>实现代码</h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">confidence</span><span class="params">(ups, downs, z)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    ups : 赞成</span></div><div class="line"><span class="string">    downs : 不赞成</span></div><div class="line"><span class="string">    z :  统计量，95%的置信水平，统计量值为1.96，可以通过查表实现</span></div><div class="line"><span class="string">    """</span></div><div class="line">    n = ups + downs</div><div class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    p = float(ups) / n</div><div class="line">    <span class="keyword">return</span> ((p + z*z/(<span class="number">2</span>*n) - z * sqrt((p*(<span class="number">1</span>-p)+z*z/(<span class="number">4</span>*n))/n))/(<span class="number">1</span>+z*z/n))</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">print</span> confidence(<span class="number">5</span>, <span class="number">0</span>, <span class="number">1.96</span>)</div><div class="line">    <span class="keyword">print</span> confidence(<span class="number">50</span>, <span class="number">10</span>, <span class="number">1.96</span>)</div><div class="line">    <span class="keyword">print</span> confidence(<span class="number">500</span>, <span class="number">100</span>, <span class="number">1.96</span>)</div><div class="line">    <span class="keyword">print</span> confidence(<span class="number">5000</span>, <span class="number">1000</span>, <span class="number">1.96</span>)</div></pre></td></tr></table></figure></p>
<p>输出结果:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0.565508505248</div><div class="line">0.719681485028</div><div class="line">0.801411699243</div><div class="line">0.823690598226</div></pre></td></tr></table></figure></p>
<h3>总结</h3>
<p>涉及到所有比例置信度的问题都可以用威尔逊区间来优化</p>
<h3>参考</h3>
<ol>
<li>http://www.ruanyifeng.com/blog/2012/03/ranking_algorithm_wilson_score_interval.html</li>
<li>https://stackoverflow.com/questions/10029588/python-implementation-of-the-wilson-score-interval</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[求解排序问题思想]]></title>
      <url>/2018/04/01/rank_problem/</url>
      <content type="html"><![CDATA[<h3>背景</h3>
<p>最近学习了rank-svm, gbrank等使用pairwise的思想来解决排序问题的方法，有些小感悟，先记录下来</p>
<h3>思想</h3>
<p>排序的偏序关系$S_{ij}$是定义出来的,</p>
<ol>
<li>if $x_i\succ x_j$, 则定义$S_{ij}=1$,</li>
<li>if $x_j\succ x_i$, 则定义$S_{ij}=-1$,</li>
<li>相等的时候, $S_{ij} = 0$</li>
<li>$\frac{1 + S_{ij}}{2}$，正好转化成了0-1区间，可以当作概率来用</li>
</ol>
<p>用gbrank举个例子，由于拟合的目标是多棵树h(x), 通过h(x)之间的偏序关系, 为了使用交叉熵来作为损失函数，我们只需将偏序关系
套入sigmoid函数转换成概率形式.</p>
<ul>
<li>$p_{ij} = p(x_i \succ x_j) = \frac{1}{1  +  exp^{(-h(x_i) + h(x_j) + \tau)}}$</li>
<li>$\overline{p_{ij}} = \frac{1 + S_{ij}}{2}$</li>
</ul>
<p>因此，我们可以构造出cross-entropy loss:
$L(h) = \sum_{i,j} {-\overline{p_{ij}}logp_{ij} - (1 - \overline{p_{ij}})log(1 - p_{ij})}$</p>
<h3>总结</h3>
<p>所以，我们可以这样想，如果我们要解决排序问题，只要我们能设计任意的函数f(x)能够表达偏序关系，都能套入cross entroy来解，我们需要求解的只是函数f(x)的参数.
比如rank_svm其实就是假设f(x)是一个线性函数，使用svm的loss函数（没有用crossEntropy）来求解f(x)的参数，当然我认为也是可以使用cross-entropy来解的（不过那样就不叫svm了）</p>
]]></content>
      
        <categories>
            
            <category> 机器学习理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[fasttext中使用的c++技巧总结]]></title>
      <url>/2018/03/06/fasttext_c_plus_tricks/</url>
      <content type="html"><![CDATA[<p>最近在研究fasttext源码，这篇文章主要分析一些非理论层面的c++的技巧。</p>
<h3>编译方面</h3>
<ol>
<li>由于需要对多线程进行支持使用了-pthread参数</li>
<li>-std=c++0x : C++11之前被称为C++0x，因为原本计划在2010年发布，所以之前一些编译器使用C++11的编译参数是：-std=c++0x，后面使用：-std=c++11</li>
</ol>
<h3>代码方面</h3>
<ol>
<li>
<p>reserve 和 resize对区别？</p>
<ul>
<li>
<p>reserve的作用是预留空间，不会创建对象，真正的数据填充需要使用push_back操作来进行。为什么要这样做？下面这个代码会导致capacity多次重新分配，去预申请内存，然后将原来地址上的所有元素拷贝到新地址上。因为vector在发现当前空间不够时，一般会把capacity进行翻倍，如果再次不够就再次翻倍, 这种效率是很低的。
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</div><div class="line">    v.push_back(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>resize是直接调整size，改变容器的大小，并且创建对象。如果new_size &gt; old_size, 则在vector增加new_size - old_size默认构造出来的元素；反之，将多出的部分删掉，但不改变capacity。</p>
</li>
</ul>
</li>
<li>
<p>lambad表达式
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; args_-&gt;thread; i++) &#123;</div><div class="line">    <span class="comment">//lambda表达式</span></div><div class="line">    threads.push_back(<span class="built_in">std</span>::thread([=]() &#123; trainThread(i); &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>lambda表达式的定义如下：[capture list] (parameter list) -&gt; return type { function body }<br>
其中capture_list的官方解释是：capture list is an (often empty) list of local variables defined in the enclosing function, 指的是lambda所在的函数中的局部变量
parameter list 指的是函数的参数，return type指的是返回类型，function body指的是函数主题。
那么，上面这段代码的意思是：lambda表达式所在函数中所有的局部变量为capture list，没有参数，没有返回值的函数。下面再举个例子说明下：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_equal</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</div><div class="line">    <span class="keyword">int</span> b = <span class="number">3</span>;</div><div class="line">    <span class="keyword">auto</span> f2 = [=]() &#123;<span class="keyword">return</span> a + b + c;&#125;;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; f2() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    test_equal(<span class="number">5</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码的输出是：5+3+5=13</p>
</li>
<li>
<p>shared_ptr智能指针
具体问题请参考这篇博客：https://www.cnblogs.com/heleifz/p/shared-principle-application.html</p>
</li>
<li>
<p>使用int32_t／int64_t
为了程序的可移植性之后要这样使用, 我们在stdint.html(https://sites.uclouvain.be/SystInfo/usr/include/stdint.h.html)中可以看到long在64位机器上是8字节的，但在32位机器上是32字节的，long是会随着机器的不同而改变的，长度是不确定的，但是使用int32_t就能保证是32位的。
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">ifndef __int8_t_defined</div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __int8_t_defined</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span>                <span class="keyword">int8_t</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">short</span> <span class="keyword">int</span>                <span class="keyword">int16_t</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>                        <span class="keyword">int32_t</span>;</div><div class="line"><span class="meta"># <span class="meta-keyword">if</span> __WORDSIZE == 64</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span>                <span class="keyword">int64_t</span>;</div><div class="line"><span class="meta"># <span class="meta-keyword">else</span></span></div><div class="line">__extension__</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>                <span class="keyword">int64_t</span>;</div><div class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Unsigned.  */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>                <span class="keyword">uint8_t</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>        <span class="keyword">uint16_t</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __uint32_t_defined</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>                <span class="keyword">uint32_t</span>;</div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __uint32_t_defined</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>        <span class="keyword">uint64_t</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">__extension__</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>        <span class="keyword">uint64_t</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
</li>
<li>
<p>utf-8编码边界在线检测
参考下阮一峰的这篇博客：
http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html<br>
如果一个字符的前两个字节是10的话，那么utf-8完整字符一定还没有结束
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Dictionary::computeSubwords(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word,</div><div class="line">                <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int32_t</span>&gt;&amp; ngrams) <span class="keyword">const</span> &#123;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; word.size(); i++) &#123;</div><div class="line">          <span class="built_in">std</span>::<span class="built_in">string</span> ngram;</div><div class="line">          <span class="keyword">if</span> ((word[i] &amp; <span class="number">0xC0</span>) == <span class="number">0x80</span>) <span class="keyword">continue</span>;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">size_t</span> j = i, n = <span class="number">1</span>; j &lt; word.size() &amp;&amp; n &lt;= args_-&gt;maxn; n++) &#123;</div><div class="line">              ngram.push_back(word[j++]);</div><div class="line">              <span class="keyword">while</span> (j &lt; word.size() &amp;&amp; (word[j] &amp; <span class="number">0xC0</span>) == <span class="number">0x80</span>) &#123;</div><div class="line">                  ngram.push_back(word[j++]);</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> (n &gt;= args_-&gt;minn &amp;&amp; !(n == <span class="number">1</span> &amp;&amp; (i == <span class="number">0</span> || j == word.size()))) &#123;</div><div class="line">                  <span class="keyword">int32_t</span> h = hash(ngram) % args_-&gt;bucket;</div><div class="line">                  pushHash(ngrams, h);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[python多线程处理文件]]></title>
      <url>/2018/03/06/multi_thread_python/</url>
      <content type="html"><![CDATA[<p>当文件特别大的时候，逐行读取文件并处理是很废时间的，目前有两种解决办法</p>
<h4>每次读取多行</h4>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">READ_SIZE是设置的读取多少个字节, 如果size小于缓冲区的大小，则读取缓冲区大小的数据;</div><div class="line">如果size大于缓冲区的大小，读取size大小的数据，但不是完全的等于size的大小;</div><div class="line">一般读取比size大的整行的数据, size最小值是1024*8. readlines不会丢失行，当size大小不处在行边界当时候。</div><div class="line"></div><div class="line">f = open(file_name)</div><div class="line">while True:</div><div class="line">    lines = f.readlines(READ_SIZE)</div><div class="line">    if not lines:</div><div class="line">        break</div><div class="line">    for line in lines:</div><div class="line">        deal_one_line()</div></pre></td></tr></table></figure></p>
<h4>多线程读取</h4>
<p>思路是，主线程负责往队列中放每一行, 很多自线程并行对数据进行处理
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">queue = Queue.Queue()</div><div class="line">class MultiThreadFile(threading.Thread):</div><div class="line">    def __init__(self, queue):</div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.queue = queue</div><div class="line"></div><div class="line">    def run(self):</div><div class="line">        while True:</div><div class="line">            line = self.queue.get()</div><div class="line">            deal_line()</div><div class="line">            self.queue.task_done()</div><div class="line"></div><div class="line">if __name__  == '__main__':</div><div class="line">    for i in range(30):</div><div class="line">        t = MultiThreadFile(queue)</div><div class="line">        t.setDaemon(True)</div><div class="line">        t.start()</div><div class="line"></div><div class="line">        f = open(USER_TERM_FILE)</div><div class="line">        while True:</div><div class="line">            lines = f.readlines(READ_SIZE)</div><div class="line">            if not lines:</div><div class="line">                break</div><div class="line">                for line in lines:</div><div class="line">                    line = line.rstrip()</div><div class="line">                    queue.put(line)</div><div class="line">        queue.join()</div></pre></td></tr></table></figure></p>
<h4>对数据切成batch处理</h4>
<p>这个程序是将数据切成200个batch，每5个batch进行并行跑，最后将batch合并下
感觉和hadoop的思想是一样的
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for((i = 1; i &lt;= 200; i++))</div><div class="line">do</div><div class="line">    sh your_program.sh $file_$i &amp;</div><div class="line">    let mod=i%5</div><div class="line">    if [ $mod -eq 0 ]</div><div class="line">    then</div><div class="line">        wait</div><div class="line">    fi</div><div class="line">done</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[cannot find -lxxx 解决方法]]></title>
      <url>/2018/03/05/ld_problem/</url>
      <content type="html"><![CDATA[<p>当从github上下载一个程序，去进行编译，经常发现系统找不到so文件，试了很多中方法都不行，非常苦恼; 这里为大家介绍下几种解决方案。</p>
<h4>通常解决方法</h4>
<ol>
<li>将so查找路径添加到LD_LIBRARY_PATH中</li>
<li>将so查找路径添加到LD_LIBRARY_PATH中</li>
<li>将so查找路径添加到 /etc/ld.so.conf</li>
</ol>
<h4>通过编写makefile解决</h4>
<p>最近从github上下载了一个工具line，试了各种方法就是找不到库，想了下这种应该在makefile中直接指定位置, makefle如下：</p>
<p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">RM=rm -rf</div><div class="line">CC=g++</div><div class="line"></div><div class="line">FLAGS= -I/usr/local/include/gsl -L/usr/local/lib/ -lgsl -lgslcblas -lpthread -O1 -g</div><div class="line"></div><div class="line">line: line.o</div><div class="line">    $(CC) -o $@ $^ $(FLAGS)</div><div class="line"></div><div class="line">line.o : line.cpp</div><div class="line">    $(CC) -c line.cpp $(FLAGS)</div><div class="line"></div><div class="line">clean:</div><div class="line">    $(RM) line *.o</div></pre></td></tr></table></figure></p>
<p>需要注意的是：</p>
<ol>
<li>我们的gsllib名称是libgsl.so, 但是在引用的时候要把前面的lib去掉，使用-lgsl</li>
<li>还需要添加 gslcblas 和 pthread才能编译通过</li>
</ol>
<h4>[ <strong>参考文档</strong> ]</h4>
<ol>
<li>https://github.com/tangjianpku/LINE</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编译 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[最大熵定义理解]]></title>
      <url>/2018/03/02/max_entropy/</url>
      <content type="html"><![CDATA[<p>第一眼看到最大熵模型，这是太突兀了，完全不知道如何想出来了，感觉国内这种直接给定义的方式限制了大家的想象力。下面解释一下这个问题：</p>
<p>熵：$H(X) = -\sum_xp(x)log(p(x))$</p>
<p>条件熵：$H(Y|X) = H(X, Y) - H(X)$</p>
<pre><code>    $= -\sum_{x,y}p(x,y)log(p(x,y)) + \sum_xp(x)log(p(x))$

    $=-\sum_{x,y}p(x,y)log(p(x,y)) + \sum_x(\sum_yp(x,y))log(p(x))$

    $= -\sum_{x,y}p(x,y)log(p(x,y)) + \sum_{x,y}p(x,y)log(p(x))$

    $= -\sum_{x,y}p(x,y)log\frac{p(x,y)}{p(x)}$

    $= - \sum_{x,y}p(x,y)log(p(y|x))$

    $=-\sum_{x,y}p(y|x)\overline{p(x)}log(p(y|x)$
</code></pre>
<p>其中加横线的p(x)表示根据数据统计出来的经验分布。</p>
<p>这里的条件熵就是统计学习方法中讲的最大熵模型，如果书本上能这样写的话，更能方便理解。</p>
<p>参考资料：</p>
<p>[1] https://kexue.fm/archives/3534/</p>
]]></content>
      
        <categories>
            
            <category> 机器学习理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[逻辑斯蒂回归另一种loss]]></title>
      <url>/2018/03/01/LR_other_loss/</url>
      <content type="html"><![CDATA[<p>统计学习方法最后一章讲到了逻辑斯蒂回归的loss func为$log[1 + exp^{-yf(x)}]$一时难以理解，找波叔帮忙看了下，给了这篇 http://pages.cs.wisc.edu/~jerryzhu/cs769/lr.pdf 参考，瞬间理解了。</p>
<p>这里主要将类别的符号变换从之前的0，1转变成了-1和1，那么最大似然估计可以统一写成：</p>
<p>$ \prod_{i=1}^n\frac{1}{1+e^{-y_i(wx_i+b)}}$</p>
<p>因为：$p(y=1|x) = \frac{1}{1+e^{-(wx+b)}}$</p>
<pre><code>  $p(y=-1|x) = 1- p(y=1|x)= \frac{1}{1+e^{wx+b}}$
</code></pre>
<p>将两个概率统一，即为最终的最大似然</p>
<p>将上面式子转换成-log形式即为loss，</p>
<p>$L(w,b) = -\sum_{i=1}^{n}log(\frac{1}{1+e^{-y_i(wx+b)}}) = \sum_{i=1}^{n}log(1+e^{-y_i(wx+b)})$</p>
]]></content>
      
        <categories>
            
            <category> 机器学习理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Logistic regression 推倒过程（使用gradient descent）]]></title>
      <url>/2018/02/18/Logistic%20regression%20%E6%8E%A8%E5%80%92%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8gradient%20descent%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>最近在学习李宏毅教授的机器学习课程，讲解的非常细致，推倒也非常详细，同时，也和线性回归做了类比，非常不错，现在这里总结一下。</p>
<h4>LR二分类推倒过程</h4>
<p>Input ：</p>
<table>
<thead>
<tr>
<th style="text-align:center">$x^1$</th>
<th style="text-align:center">$x^2$</th>
<th style="text-align:center">$x^3$</th>
<th>...</th>
<th>$x^n$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$C_1$</td>
<td style="text-align:center">$C_1$</td>
<td style="text-align:center">$C_2$</td>
<td>...</td>
<td>$C_2$</td>
</tr>
<tr>
<td style="text-align:center">$\hat{y^1}=1$</td>
<td style="text-align:center">$\hat{y^2}=1$</td>
<td style="text-align:center">$\hat{y^3}=0$</td>
<td></td>
<td>$\hat{y^n}=0$</td>
</tr>
</tbody>
</table>
<p>其中第一行表示所有的变量，第二行表示属于的类别，这里之后两类。</p>
<h4>最大似然估计</h4>
<p>由于LR使用的是回归函数是$\frac{1}{1+e^{-x}}$, 值域是(0,1)，可以天然的表示概率，我们用$f_{w,b}(x)$表示x属于$C_1$ 的概率，w,b表示参数，那么属于$C_2$的概率可以表示为$1-f_{w,b}(x)$。这个时候，我们就能够用最大似然估计来解这个问题。</p>
<p>定义 $L(w,b) = f_{w,b}(x^1)*f_{w,b}(x^2)(1-f_{w,b}(x^3))...$</p>
<p>那么：$w^{*}, b^{*} = arg, \underset{w,b}{max}L(w, b)​$</p>
<p>​           $w^{*}, b^{*} = arg, \underset{w,b}{min}-ln(L(w,b))$</p>
<p>即：将最大似然估计转化成了loss，并且将之前的乘法转换成了加法，下面具体求解：</p>
<p>$arg,\underset{w,b}{min}-ln(L(w,b)) = -ln(f_{w,b}(x^1))-ln(f_{w,b}(x^2))-ln(1-f_{w,b}(x^3))$</p>
<h4>符号变换</h4>
<p>下面需要做下符号变换，将所有的$C_1$看成1, 所有的$C_2$看成0, 并记为：$\hat{y^n}$</p>
<p>那么，为了将两种格式的式子写成一个式子，我们做如下的变换：</p>
<p>$-ln(f_{w,b}(x^1))=-[\hat{y^1}ln(f(x^1)) + (1-\hat{y^1})ln(1-f(x^1))]$</p>
<p>$-ln(f_{w,b}(x^2))=-[\hat{y^2}ln(f(x^2)) + (1-\hat{y^2})ln(1-f(x^2))]$</p>
<p>$-ln(f_{w,b}(x^3))=-[\hat{y^3}ln(f(x^3)) + (1-\hat{y^3})ln(1-f(x^3))]$</p>
<p>只需要简单带入进去就可以理解了。</p>
<p>合并起来：</p>
<p>$\sum\limits_{n}-[\hat{y^n}ln(f(x^n)) + (1-\hat{y^n})ln(1-f(x^n))]$，这个其实就是两个伯努利分布的交叉熵，也就是说LR的loss func使用的是交叉熵。</p>
<h4>求导</h4>
<p>对其中一个变量$w_i$进行求导，我们只需要$ln(f(x^n))$和$ln(1-f(x^n))$对$w_i$进行求导。</p>
<p>$\frac{\partial ln(f_{w,b}(x))}{\partial w_i} = \frac{\partial ln(f_{w,b}(x))}{\partial z}\frac{\partial z}{\partial w_i}$，$z=wx + b = \sum\limits_{i}w_ix_i+b$, $f_{w,b}(x)) = \frac{1}{1+e^{-z}}$</p>
<p>化简后可以得到：</p>
<p>$\sum\limits_{n}-(\hat{y^n} - f_{w,b}(x^n))*{x^{n}_{i}}$</p>
<p>由此得到参数更新的方法：</p>
<p>$w_i \leftarrow w_i - \eta\sum\limits_{n}-(\hat{y^n} - f_{w,b}(x^n))*{x^{n}_{i}}$</p>
<h4>源码地址</h4>
<p>https://github.com/c00h00g/FastLR</p>
]]></content>
      
        <categories>
            
            <category> 机器学习理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用nodejs + express搭建网站]]></title>
      <url>/2018/02/13/node_express/</url>
      <content type="html"><![CDATA[<p>最近在一个项目中，经常会遇到一些case需要追查，直接到数据中进行grep，效率太低，耗费大量时间，于是学习了express搭建一个可视化前端，对程序进行打点，追查到底哪一部分出了问题。现在总结一下：</p>
<h3>如何入门？</h3>
<p>入门可以直接参考byvoid的Nodejs开发指南，内容讲的非常详细，直接有实例代码。需要说明的是express目前生成的模版不是ejs，而是jade。</p>
<p>对于javascript／css／jquery的学习，可以使用xxx菜鸟教程，里面的实例也比较清晰。</p>
<h3>如何安装express</h3>
<p>目前支持两个版本，之前书上讲的不可用，需要按照下面的方式安装
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g express-generator@3</div><div class="line">npm install -g express-generator@4</div></pre></td></tr></table></figure></p>
<h3>一些细节问题</h3>
<h4>1. 如何从后端向前端传递数据</h4>
<p>使用如下方式, 其中key是jade可以拿到的访问数据的key，data是具体的数据
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">res.render(&apos;index&apos;,&#123;</div><div class="line">    key : data,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在jade中获取的数据可以通过#{key}来获取</p>
<h4>2. 后端如何获取前端传递过来的数据？</h4>
<p>首先，前端的控件，比如文本框，必须要有name字段, 后段是根据name字段来取到最终的数据的。
后端使用方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">获取控件上的值 ： req.body.name</div><div class="line">打印body全部数据 ： JSON.stringify(req.body）</div></pre></td></tr></table></figure></p>
<h4>3. jade中如何使用js</h4>
<p>比如弹出一个提示框 &amp;&amp; 添加onclick操作(需要在button添加onclick事件)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">script.</div><div class="line">  alert(&apos;use js in jade&apos;);</div><div class="line">  function click_func() &#123;</div><div class="line">    alert(&apos;use js in jade&apos;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>另外：jade本身就支持for／if等语法，如果要打印数据需要使用#{xx}来修饰变量</p>
<h4>4. 如何使用bootstrap</h4>
<ol>
<li>
<p>安装bootstrap, 在app.js同级目录下执行
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install bootstrap --save</div><div class="line">npm install jquery --save</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>打开app.js, 找到express.static, 下面添加一行
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#app.use(express.static(path.join(__dirname, &apos;public&apos;)))</div><div class="line">app.use(&apos;/lib&apos;,express.static(path.join(__dirname, &apos;node_modules&apos;)));</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>在views下创建includes目录，在目录下新建head.jade, 写入如下内容
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">link(href=&quot;/lib/bootstrap/dist/css/bootstrap.min.css&quot;, rel=&quot;stylesheet&quot;)</div><div class="line">script(src=&quot;/libs/jquery/dist/jquery.min.js&quot;) </div><div class="line">script(src=&quot;/libs/bootstrap/dist/js/bootstrap.min.js&quot;)</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>在layout.jade中引入head.jade
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">doctype html</div><div class="line">html</div><div class="line">  head</div><div class="line">    title= title</div><div class="line">    link(rel=&apos;stylesheet&apos;, href=&apos;/stylesheets/style.css&apos;)</div><div class="line">    include ./includes/head</div><div class="line">  body</div><div class="line">    block content</div></pre></td></tr></table></figure></p>
</li>
</ol>
<h4>5. 如何同步读取大文件</h4>
<p>超过一定大小的文件，直接使用readFileSync会读取失败，网上提供了一些异步readline的方法，如果要同步读取的话，可以使用如下方法：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;)</div><div class="line">var offset = 0;</div><div class="line">var chunkSize = 204800;</div><div class="line">var chunkBuffer = new Buffer(chunkSize);</div><div class="line">var fp = fs.openSync(path, &apos;r&apos;);</div><div class="line">var bytesRead = 0;</div><div class="line">while(bytesRead = fs.readSync(fp, chunkBuffer, 0, chunkSize, offset)) &#123;</div><div class="line">    offset += bytesRead;</div><div class="line">    var str = chunkBuffer.slice(0, bytesRead).toString();</div><div class="line">    var arr = str.split(&apos;\n&apos;);</div><div class="line"></div><div class="line">    #最后一个可能不是完整的一行，需要删掉</div><div class="line">    if(arr.length &gt; 1) &#123;</div><div class="line">        offset -= arr.pop().length;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">这个程序的每次读取的大小的代码根据需要微调下。</div></pre></td></tr></table></figure></p>
<h4>6. 一些有用的网址</h4>
<ol>
<li>html to Jade : http://html2jade.vida.io/</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[自己给自己提问(FAQ)]]></title>
      <url>/2018/02/10/ask_myselfs/</url>
      <content type="html"><![CDATA[<h3>收集自己每天想到的一些问题</h3>
<ol>
<li>机器学习中都有哪些采样算法？</li>
<li>LR多分类如何推导的？</li>
<li>机器学习中的一些指标具体是指什么？比如AUC，ROC，F1等</li>
<li>LR为什么要对特征归一化？</li>
<li>最大似然估计取-log之后是否就是loss？</li>
<li>朴素贝叶斯哪儿使用到了EM算法？</li>
<li>皮尔森系数？</li>
<li>jensen不等式？</li>
<li>LR和最大熵的关系？</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 问自己 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[经常看的一些链接]]></title>
      <url>/2018/02/05/useful_url/</url>
      <content type="html"><![CDATA[<h4>常用链接</h4>
<ol>
<li>机器学习：http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML17_2.html</li>
<li>深度学习：https://www.csie.ntu.edu.tw/~yvchen/f106-adl/syllabus.html</li>
<li>deeplearning &amp; nlp</li>
</ol>
<ul>
<li>http://cs224n.stanford.edu/syllabus.html</li>
<li>http://cs224d.stanford.edu/syllabus.html</li>
</ul>
<ol start="4">
<li>cnn &amp; cv : http://cs224d.stanford.edu/syllabus.html</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 程序技巧 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[FM算法解析]]></title>
      <url>/2018/02/01/FM%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3>背景</h3>
<p>FM算法全称</p>
]]></content>
      
        <categories>
            
            <category> 机器学习理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[RANK_SVM算法解析]]></title>
      <url>/2018/02/01/Rank_SVM/</url>
      <content type="html"><![CDATA[<h3>RANK_SVM 原理</h3>
<p>RankSVM基于SVM算法，将pair-wise的排序问题，转化为分类问题</p>
<h3>SVM算法回顾</h3>
<ol>
<li>
<p>SVM的优化目标
$min \frac{1}{2}||w^2|| $
$s.t. y_i(w^Tx_i+b) &gt;= 1(i = 1, 2, 3 … n)$</p>
</li>
<li>
<p>使用拉格朗日函数 --&gt; 转化为对偶问题来求解</p>
</li>
<li>
<p>SVM使用的loss func为hinge loss(合页损失函数)
$min_{w,b}[1 - y_i(w*x + b)]_+ + \lambda||w||_2^2$</p>
</li>
</ol>
<h3>RANK_SVM介绍</h3>
<ol>
<li>
<p>定义1：f是排序函数，$x_i\succ x_j \Longleftrightarrow f(x_i) &gt; f(x_j)$, 表示如果$f(x_i) &gt; f(x_j)$，$x_i$需要排在$x_j$的前面</p>
</li>
<li>
<p>定义2：假设f(x)是一个线性函数，$f(x) = \langle w, x \rangle$ 表示参数向量w和特征向量x的点乘(inner product)</p>
</li>
<li>
<p>定义3，我们可以将排序问题转换为分类问题
$f(x_i) &gt; f(x_j) \Longleftrightarrow  \langle w, x_i - x_j \rangle &gt; 0$</p>
</li>
<li>
<p>定义4定义y表示label值, 区值范围+1和-1，</p>
<ul>
<li>y = +1, $if \langle w, x_i - x_j \rangle &gt; 0$</li>
<li>y = -1, $if \langle w, x_i - x_j \rangle &lt; 0$
这样，我们就将排序问题转换成了分类问题</li>
</ul>
</li>
</ol>
<h3>如何求解</h3>
<p>这里，传统的SMO优化方法，我们这里不再做具体的介绍，在实做上，我们一般使用的是SGD方法
既然我们已经有了loss function，我们当然可以通过sgd的方法来解</p>
<h4>loss func</h4>
<ul>
<li>loss = $min_w  \frac{\lambda}{2}||w||^2 + \sum_{(d_i, d_j)}max(0,  1 - y_{(d_i, d_j)}\langle w, x_{d_i} - x_{d_j} \rangle)$</li>
<li>grad = $\lambda w - \sum_{i,j}I(y_{i,j} \langle w, x_i - x_j\rangle &lt; 1)y_{i,j}(x_i - x_j)$</li>
</ul>
<h3>参考</h3>
<ol>
<li>https://github.com/glycerine/sofia-ml, google实现的ranksvm</li>
<li>learning to rank by lihang</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 机器学习理论 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[如何使用python调用so接口]]></title>
      <url>/2018/01/07/python%E8%B0%83%E7%94%A8so%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h4>如何生成so文件？</h4>
<p>为了生成so文件，只需要修改makefile中的编译参数，主要是加上-shared等参数。我们下面会用一个实例来说明：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//test_ctypes.cpp</div><div class="line">#include &quot;test_ctypes.h&quot;</div><div class="line"></div><div class="line">A::A(int n) &#123;</div><div class="line">    num = n;</div><div class="line">&#125;</div><div class="line"></div><div class="line">A::~A() &#123;</div><div class="line">    num = 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int A::get_num() &#123;</div><div class="line">    return num;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//封装</div><div class="line">extern &quot;C&quot; &#123;</div><div class="line">    void* get_instance(int n) &#123;</div><div class="line">        return new(std::nothrow)A(n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int get_num(void* ptr) &#123;</div><div class="line">        assert(NULL != ptr);</div><div class="line">        A* a = reinterpret_cast&lt;A*&gt;(ptr);</div><div class="line">        return a-&gt;get_num();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&lt;!-- more --&gt;</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//test_ctypes.h</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;assert.h&gt;</div><div class="line">#include &lt;new&gt;</div><div class="line"></div><div class="line">class A &#123;</div><div class="line">public:</div><div class="line">    A(int n);</div><div class="line">    virtual ~A();</div><div class="line">    int get_num();</div><div class="line">private:</div><div class="line">    int num;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//makefile</div><div class="line">RM=rm -rf</div><div class="line">CXX=g++</div><div class="line"></div><div class="line">test_ctypes.so : test_ctypes.o</div><div class="line">    $(CXX) -fPIC -shared -o $@ $^</div><div class="line"></div><div class="line">test_ctypes.o : test_ctypes.cpp test_ctypes.h</div><div class="line">    $(CXX) -fPIC -c -o $@ $&lt;</div><div class="line"></div><div class="line">clean:</div><div class="line">    $(RM) test_ctypes.o</div><div class="line">    $(RM) test_ctypes.so</div></pre></td></tr></table></figure></p>
<h4>如何使用ctypes生成python调用接口？</h4>
<p>模块ctypes是Python内建的用于调用动态链接库函数的功能模块，但是，在调用C++代码的时候，需要对代码中的函数使用extern &quot;C&quot;进行封装。原因是，由于C++多了函数重载的功能，导致了一个函数不能仅仅用它的名字来确定，编译器会将名字优化成并不是程序中看到的名字。下面是如何在python中使用：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#-*- coding:utf-8 -*-</div><div class="line"></div><div class="line">import ctypes</div><div class="line">so = ctypes.cdll.LoadLibrary</div><div class="line">test_ctypes = so(&apos;./test_ctypes.so&apos;)</div><div class="line">test_ctypes_ins = test_ctypes.get_instance(4)</div><div class="line">print test_ctypes.get_num(test_ctypes_ins)</div></pre></td></tr></table></figure></p>
<p>输出结果是：4</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Makefile小结]]></title>
      <url>/2018/01/01/Makefile%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<ul>
<li>-fPIC :  编译共享库（-shared）</li>
<li>-Wall : 编译后显示所有警告</li>
<li>-pipe : 使用管道代替临时文件</li>
<li>-Idir : 将dir加入搜索头文件的路径列表</li>
<li>-w : 禁止显示所有警告信息</li>
<li>-Xlinker : 用于链接很多静态库, <strong>-Xlinker “-(&quot; libtest1.a  libtest2.a-Xlinker “-)&quot;</strong>，如果libtest2.a中使用了libtest1.a中的接口，不使用这个关键字的话，必须将libtest2.a写在libtest1.a前面，加了这个参数之后则没有这个限制</li>
<li>-lpthread : 多线程链接</li>
<li>-lcrypto : 链接crypto库，用于加密</li>
<li>-g :  支持gdb调试用</li>
<li>$@ : 目标文件</li>
<li>$^ : 所有依赖文件</li>
<li>$&lt; : 第一个依赖的文件</li>
<li>ar rcs : 生成.a文件</li>
<li>-static : 使用静态编译，把动态库的函数和所依赖的东西都编译进本程序，生成文件会非常大，但运行时不需要任何动态库</li>
<li>makefile中的命令前要使用tab</li>
<li>-D : 通过宏定义控制源程序的编译, 在程序中通过#ifdef/#else/#endif来控制</li>
<li>linux程序安装过程</li>
</ul>
<ol>
<li>./configure : 用来生成makefile，--prefix用来制定安装的路径，比如：./configure --prefix = /home/work/python, 则执行文件会安装在/home/work/python/bin目录下，资源文件会安装在/home/work/python/share目录下</li>
<li>make : 编译程序</li>
<li>make install : 安装</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编译 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[tmux常用命令]]></title>
      <url>/2017/10/22/tmux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h4>基本概念</h4>
<ol>
<li>session</li>
<li>window</li>
<li>panel</li>
</ol>
<h4>主要命令</h4>
<h5>session</h5>
<ol>
<li>
<p>新建一个tmux session
直接在终端输入tmux
或者tmux new -s session_name</p>
</li>
<li>
<p>列出所有session
tmux ls</p>
</li>
</ol>
<p>&lt;!-- more --&gt;</p>
<ol start="3">
<li>
<p>加载一个session
tmux a -t session_id</p>
</li>
<li>
<p>脱离当前session
prefix + d</p>
</li>
<li>
<p>删除session
tmux kill-session -t session_id</p>
</li>
<li>
<p>重命名session
prefix + $</p>
</li>
</ol>
<h5>window</h5>
<ol>
<li>
<p>新建窗口
prefix + c</p>
</li>
<li>
<p>重命名窗口
prefix + ，</p>
</li>
<li>
<p>切换到具体某个窗口
prefix + window_id</p>
</li>
<li>
<p>关闭当前窗口
prefix + &amp;</p>
</li>
</ol>
<h5>panel</h5>
<ol>
<li>
<p>上下分屏
prefix + %</p>
</li>
<li>
<p>左右分屏
prefix + ”</p>
</li>
<li>
<p>取消分屏
prefix + x</p>
</li>
<li>
<p>如何滚屏
prefix + pageUp/PageDown(mac上对应fn+上下键)</p>
</li>
</ol>
<p><em>注意</em></p>
<ol>
<li>prefix指的是操作的快捷键ctrl + b</li>
<li>当然这些都是用到的一些最基础的操作，也可以通过修改.tmux.conf来自己配制</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 程序技巧 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[统计学习方法第一章习题]]></title>
      <url>/2017/10/22/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3>习题1.1</h3>
<p>问题：假设观测到伯努利模型n次独立的数据生成结果，其中k次的结果为1，这时可以用极大似然估计或者贝叶斯估计来估计结果为1的概率</p>
<h4>极大似然估计法</h4>
<p>$L(\theta) = \theta^k(1-\theta)^{n-k}$</p>
<p>对$\theta$求导</p>
<p>$L'(\theta) = k\theta^{k-1}(1-\theta)^{n-k} + \theta^{k}(n-k)(1-\theta)^{n-k-1}(-1) = 0$</p>
<p>=&gt; $k(1-\theta) = \theta(n-k)$</p>
<p>=&gt; $k = \theta n$</p>
<p>=&gt;$\theta = \frac{k}{n}$</p>
]]></content>
      
        <categories>
            
            <category> 统计学习方法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[core调试技巧]]></title>
      <url>/2017/10/15/core%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h4>常用gdb命令</h4>
<ol>
<li>查看堆栈信息
bt</li>
<li>进入到某个堆栈中
f n : n是堆栈的id</li>
<li>gdb打印结构体更漂亮
set print pretty</li>
<li>查看函数参数信息
info args</li>
<li>查看函数局部变量信息
info locals</li>
<li>查看线程信息
info threads
thread n : 进入第n个线程</li>
</ol>
<h4>Mac上查看core</h4>
<ol>
<li>出core只有段错误信息，却没有core
需要执行命令：ulimit -c unlimited</li>
<li>Mac下core是被写入到/cores目录下的，需要在这个目录下查看core</li>
<li>如何查看core
lldb --core core.xxx</li>
</ol>
<h4>[ <strong>参考文档</strong> ]</h4>
<ol>
<li>http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</li>
<li>https://wizardforcel.gitbooks.io/100-gdb-tips/  100个gdb小技巧</li>
<li>http://blog.afantree.com/unixlinux/how-to-generate-core-dumps-in-mac-os-x.html</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 调试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[一些实用技巧]]></title>
      <url>/2017/04/10/some-tricks/</url>
      <content type="html"><![CDATA[<ul>
<li>
<p>sort排序的时候要加上 &lt;font color=blue&gt;LC_ALL=C&lt;/font&gt;, 否则排序可能不符合预期，具体请参考<a href="http://unix.stackexchange.com/questions/87745/what-does-lc-all-c-do" target="_blank" rel="external">文章</a></p>
</li>
<li>
<p>如何删除行尾的^M特殊符号：&lt;font color=blue&gt;%s/\r//g&lt;/font&gt;</p>
</li>
<li>
<p>如何将urlencode后的编码还原
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> unquote</div><div class="line">str = <span class="string">'%E7%88%86%E6'</span></div><div class="line"><span class="keyword">print</span> unquote(str)</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>如何将在一个版本上开发的代码移植到另一个版本上
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">svn diff &gt; code.diff</div><div class="line">patch -p0 -i code.diff</div><div class="line">注意：可能会有拒绝，以.rej结尾，所有patch完之后，一定别忘了执行命令：</div><div class="line">find . -name <span class="string">"*.rej"</span> 来合并下diff</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>sort排序指定分隔符
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sort -t $'\t' : 使用-t参数, 注意是单引号</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>std::sort，cmp函数在元素相等时要返回false,否则会core掉，可以使用<strong>stable_sort</strong></p>
</li>
<li>
<p>求差集
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a-b : grep -F -v -f b a | sort | uniq</div><div class="line">b-a : grep -F -v -f a b | sort | uniq</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>grep</p>
<ul>
<li>忽略大小写：-i</li>
<li>查询二进制文件：-a (相当于--binary-files=text)</li>
</ul>
</li>
<li>
<p>压缩 &amp; 解压</p>
<ul>
<li>
<p>tar
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">压缩：tar  -zcvf  xxx.tar.gz  yourdirectory</div><div class="line">解压：tar  -zxvf  xxx.tar.gz</div><div class="line"></div><div class="line">只打包不压缩 ：tar -cvf xxx.tar yourdirectory</div><div class="line">解包：tar -xvf xxx.tar</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>zip
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">解压：unzip xxx.zip</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>tar.bz2
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bzip2 -d filename.tar.bz2, 生成filename.tar</div><div class="line">tar -xvf filename.tar</div></pre></td></tr></table></figure></p>
</li>
</ul>
</li>
<li>
<p>wget</p>
<ul>
<li><strong>nohup wget -r -l0 --preserve-permissions ftp_file &amp;</strong></li>
<li>preserve-permissions : 保存权限</li>
<li>-l0 ：表示一直递归到最后一层，防止目标文件层次过多导致无法完全wget下来</li>
<li>-nH --cut-dirs=5 表示wget的时候使用目录裁剪</li>
</ul>
</li>
<li>
<p>lsof</p>
<ul>
<li>lsof -i:port_id : 查看端口号对应的进程id</li>
</ul>
</li>
<li>
<p>删除文件中的^@</p>
<ul>
<li>^@就是\0, 执行命令: sed -r 's/\x0//g'</li>
<li>输入ctrl+V ctrl+@, 可以在vim中打出来，直接在vim中替换</li>
</ul>
</li>
<li>
<p>文档转换成unix格式, 删除文档中包含^M</p>
<ul>
<li>dos2unix</li>
</ul>
</li>
<li>
<p>linux安装需要注意的PATH</p>
<ul>
<li>动态链接库：LD_LIBRARY_PATH，使用的时候需要: export LD_LIBRARY_PATH = new_installed:$LD_LIBRARY_PATH</li>
<li>可执行程序的查找路径：PATH, 使用的时候需要: export PATH = new_installed:$PATH</li>
</ul>
</li>
<li>
<p>删除源码软件安装</p>
<ul>
<li>1.找到安装目录，执行命令make uninstall</li>
<li>2.如果第一步无法删除成功，说明不支持这种卸载方式，可以通过执行whereis查看可执行文件／lib等文件安装到了什么位置，然后执行rm删除</li>
</ul>
</li>
<li>
<p>使用python生成随机数
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line">rand_list = [ random.randint(<span class="number">0</span>, <span class="number">100000</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>) ]</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>将一个文件中特定的文件拷贝到另一个文件
比如：将a文件中所有cpp文件拷贝到b文件 使用xargs实现
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find a -name "*.cpp" | xargs -i cp &#123;&#125; b</div></pre></td></tr></table></figure></p>
<p>其中：-i表示find传递给xargs的结果由{}来代替</p>
</li>
<li>
<p>map和unordered_map的区别</p>
<ol>
<li>map内部是红黑树实现的，内部是有序的</li>
<li>unordered_map内部实现了一个哈希表，无序的</li>
</ol>
</li>
<li>
<p>用vector接收用户输入参数
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char** argv) &#123;</div><div class="line">    std::vector&lt;std::string&gt; args(argv, argv + argc);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>grep显示匹配行之前之后n行
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-A n 显示匹配行和之后的n行</div><div class="line">-B n 显示匹配行和之前的n行</div><div class="line">-C n 显示匹配行之后和之后各n行</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>mount硬盘
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lsblk : 查看当前磁盘的情况</div><div class="line">mount /dev/sdb /disk : 前面是磁盘位置，后面是挂载目录</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>多线程不要使用cout
多线程情况下使用cout &lt;&lt; a &lt;&lt; endl, &lt;&lt;中间可能被中断掉，建议使用printf</p>
</li>
<li>
<p>linux机器登录后很快自动退出
解决方案：/etc/profile 中设置TIMEOUT 改大一些</p>
</li>
<li>
<p>查看进程id对应的程序路径
ll /proc/PID</p>
</li>
<li>
<p>修改文件夹所有权
chown -R username:username /xxxx/xxxx/xxx</p>
</li>
<li>
<p>shell计算绝对值
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span>&#123;res#-&#125;, 解释：$&#123;var#Pattern&#125; Remove from $var the shortest part of $Pattern that matches the front end of $var</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>shell while忽略循环条件
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while :; do</div><div class="line">    command</div><div class="line">done</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>BeautifulSoup避免标签自动转小写, 使用xml方式打开
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">soup = BeautifulSoup(open(<span class="string">"test.xml"</span>), <span class="string">'xml'</span>)</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>shell多行注释
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;EOF</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>shell相等判断</p>
<ol>
<li>整型 : eq</li>
<li>字符串 : =</li>
</ol>
</li>
<li>
<p>shell获取日期
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">today=`date +%Y%m%d`</div><div class="line">yesterday=`date -d "1 days ago $today" +%Y%m%d`</div></pre></td></tr></table></figure></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 程序技巧 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Define可变参数解决函数特殊条件判断]]></title>
      <url>/2017/04/06/define_multi_arg/</url>
      <content type="html"><![CDATA[<p>在写c／c++程序的时候，经常要处理很多异常的情况，我们希望设计一个通用的判断错误的功能：</p>
<ol>
<li>能够在函数内部返回值</li>
<li>能够打印log</li>
</ol>
<p>define可以实现此功能，因为宏具有可以将代码展开的功能，因此能够实现return的功能。我们看个例子：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_LOG(expr, ret, msg, args...) do&#123; \</span></div><div class="line"><span class="keyword">if</span> (expr) &#123; \</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, msg, ## args); \</div><div class="line">    <span class="keyword">return</span> ret; \</div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">    ERROR_LOG(a &lt; <span class="number">5</span>, <span class="number">-1</span>, <span class="string">"a &lt; 5 is forbidden! a= [%d] \n"</span>, a);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> res = fun(<span class="number">3</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"res=[%d]\n"</span>, res);</div><div class="line"></div><div class="line">    res = fun(<span class="number">6</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"res=[%d]\n"</span>, res);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码的输出是：
a &lt; 5 is forbidden! a= [3]
res=[-1]
res=[0]</p>
<p>这样设计的好处是，宏直接在函数中展开，可以返回值，使得代码更加简洁
另外：</p>
<ol>
<li>为什么要使用do while（0）请参考：@<a href="https://stackoverflow.com/questions/257418/do-while-0-what-is-it-good-for" target="_blank" rel="external">stackoverflow</a>.</li>
<li>define中，单个#表示使后面的参数变为字符串，而##表示两个参数拼接成字符串.</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 程序技巧 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[git用法总结]]></title>
      <url>/2017/04/02/git%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<ul>
<li>
<p>1、git提交代码
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git status 查看需要add哪些文件</div><div class="line">git add 修改的文件</div><div class="line">git commit -m "comments" </div><div class="line">git push（先输下这个命令，之后会提示正确的命令）</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>2、git 新建本地分支并关联到远程分支
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout -b branch_name : 新建本地分支</div><div class="line">git push origin branch_name : 提交分支到远程仓库</div><div class="line">git branch --set-upstream branch-name origin/branch-name : 关联远程分支</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>3、git回退到某个分支的特定版本
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard 版本号 ： 其中版本号可以通过git log命令查看</div></pre></td></tr></table></figure></p>
</li>
</ul>
<pre><code>这儿需要注意的是，这个命令会导致当前修改的文件丢失，需要对修改的文件进行备份
</code></pre>
<ul>
<li>
<p>4、git查看diff
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git diff version1 version2 ：一个分支的不同版本的diff, 注意中间没有冒号，这个和svn不一样</div><div class="line">git diff branch1..branch2 : 不同分支的diff</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>5、git patch diff文件
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git diff xxx &gt; diff.patch</div><div class="line">git apply diff.patch</div></pre></td></tr></table></figure></p>
</li>
</ul>
<pre><code>path后出错的解决方案：https://segmentfault.com/q/1010000008958193
</code></pre>
<ul>
<li>
<p>6、如何拉取单个文件？
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout 远程分支名  文件路径， 比如：git checkout branch_name  include/xxx/xxx.h，会将xxx.h文件拉取下来</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>7、如何不commit代码，就能pull回主干代码？
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git stash</div><div class="line">git pull</div><div class="line">git stash pop</div></pre></td></tr></table></figure></p>
</li>
</ul>
<pre><code>git stash, stash是储藏的意思，用于保存当前的工作点；试想，当在某个分支上开发，突然需要切换分支，但还不能提交正在进行的工作，需要对这些修改进行存储，需要使用的命令就是git stash。当需要恢复之前的工作点时候，需要使用命令：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git stash list</div><div class="line">git stash apply</div><div class="line">git stash apply stash@&#123;2&#125; // 如果有多个stash</div></pre></td></tr></table></figure>
</code></pre>
<ul>
<li>
<p>8、回滚单个文件
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git log filename，找到要恢复的版本</div><div class="line">git reset 7f1a4c4055e93908818251596177bb476010d013 filename，这个时候能看到diff</div><div class="line">git checkout -- filename，丢弃工作区的修改</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>9、修改文件后，不重复commit
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add 修改的文件</div><div class="line">git commit --amend -m "注释", 其中amend的注释会作为最终的注释</div></pre></td></tr></table></figure></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 程序技巧 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[GRPC安装]]></title>
      <url>/2017/02/10/grpc_install/</url>
      <content type="html"><![CDATA[<h4>背景</h4>
<p>grpc是google发布的一款开源的rpc框架，使用protobuf作为序列化工具，相关代码都可以在github上搜到。rpc即远程过程调用，可以在客户端调用服务端的程序，同时可以支持不同语言之间的相互调用，比如：使用php作为前端的架构，c++作为后端语言，可以使用php调用后端c++服务端的函数接口。</p>
<h4>安装步骤</h4>
<ol>
<li>
<p>下载源码并编译安装
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git clone -b $(curl -L https:<span class="comment">//grpc.io/release) https://github.com/grpc/grpc</span></div><div class="line">cd grpc</div><div class="line">git submodule update --init</div><div class="line">make</div><div class="line">[sudo] make install</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>进入grpc/examples/cpp/helloworld目录，并make，这个时候会提示protobuf没有安装</p>
</li>
<li>
<p>进入目录grpc/third_party/protobuf, 编译并安装protobuf
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make </div><div class="line">make install</div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>[<strong>参考文档</strong>]</p>
<ol>
<li>https://doc.oschina.net/grpc grpc文档</li>
<li>https://github.com/grpc/grpc grpc</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 程序技巧 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[开始重新写博客]]></title>
      <url>/2016/10/09/my-first-blog/</url>
      <content type="html"><![CDATA[<p>翻了一下自己之前写过的最后一篇博客，日期是2013年12月13日，距离现在已经有3年了。之前写博客主要是将自己做过的编程题目记录下来，也算坚持了很长时间。这是之前<a href="http://blog.csdn.net/chen895281773/" target="_blank" rel="external">博客地址</a>。</p>
<p>工作之后发现，写一些东西还是很能够加深对问题的理解的，很多你想逃避的知识点，由于必须写下来，也必须弄清楚了。</p>
<p>之后的博客内容主要关注一下几点：</p>
<ul>
<li>机器学习读书、视频笔记</li>
<li>自己的一些思考</li>
</ul>
<p>希望自己可以坚持下来！</p>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
